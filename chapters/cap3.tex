\chapter{O Framework ETL4NoSQL}
% ---
Neste capítulo são apresentados os conceitos do framework ETL4NoSQL, que consiste numa plataforma de software para desenvolvimento de sistemas de ETL, mais especificamente uma ferramenta que auxilia a construção de processos de ETL buscando apoiar a modelagem e o desempenho dos processos. 

O ETL4NoSQL oferece um ambiente integrado para modelar processos de ETL e implementar funcionalidades utilizando uma linguagem de programação independente de uma GUI (\emph{Graphical User Interface} - Interface Gráfica do Usuário).


Para a especificação do \textit{framework} proposto foram  elencados os requisitos de software, utilizada a abordagem de desenvolvimento baseado em componentes fundamentada no estudo de \cite{cheesman:2001}, onde tem-se a separação entre modelagem do domínio e da especificação. A modelagem de domínio consiste na definição dos casos de uso, do modelo conceitual e do modelo comportamental. Já a modelagem de especificação é segmentada em três partes, a parte de identificação de componentes, de interação entre os componentes e a especificação de componentes.  

%definidas as estruturas de dados dos ambientes de origem, destino e da área de processamento de dados e suas respectivas linguagens de manipulação de dados, e também, as principais funcionalidades dos sistemas de ETL, chamados mecanismos de ETL. Para realizar os processos de ETL, por meio de seus mecanismos, foi definido um controlador de operações que é capaz de se comunicar com os ambientes e os mecanismos de ETL. 

A seguir, são detalhados os requisitos de software, os modelo de domínio, os modelos de especificação e as especificações dos componentes do ETL4NoSQL

% a arquitetura do sistema e a estrutura dos componentes utilizados no desenvolvimento do framework.

\clearpage
% ---
\section{Requisitos de software do ETL4NoSQL}


Requisitos de software são descrições de como o sistema deve se comportar, definidos durante as fases iniciais do desenvolvimento do sistema como uma especificação do que deveria ser implementado (\cite{sommerville:2013}). Os requisitos podem ser divididos em funcionais e não funcionais, onde o primeiro descreve o que o sistema deve fazer, ou seja, as transformações a serem realizadas nas entradas de um sistema a fim de que se produzam saídas, já o outro expressa as características que este software vai apresentar (\cite{sommerville:2013}). 

O ETL4NoSQL é um \textit{framework} que tem como principal objetivo auxiliar na criação de processos de ETL ao se utilizar diversas estruturas de armazenamento de dados. Um sistema de software pode ter seus dados armazenados em bases relacionais, que seguem o modelo entidade e relacionamento, ou não relacionais, onde esta possui pouca definição de esquema, não segue um modelo específico e são regularmente chamados de NoSQL (\cite{fowler:2013}). As bases NoSQL possuem quatro paradigmas frequentemente utilizados: Chave-Valor, Família de Colunas, Documentos e Grafo (\cite{fowler:2013}).

As bases de dados relacionais utilizam uma linguagem de gerenciamento de dados padrão conhecida por SQL (Structure Query Language) (\cite{fowler:2013}), porém as bases de dados NoSQL não possuem uma linguagem em comum, como as relacionais, cada estrutura de armazenamento possui sua própria linguagem de gerenciamento de dados (\cite{fowler:2013}). Por isso, é essencial que haja um componente que seja capaz de fazer a leitura diretamente da fonte de dados e um componente que também possa carregar esses dados diretamente no seu destino, independente do seu tipo, saber se é um arquivo texto,  um arquivo XML, RDBMS, NoSQL, entre outros. Um componente tem como uma de suas definições ser uma unidade de \textit{software} independente, que encapsula a sua implementação, e oferece serviços por meio de suas interfaces (\cite{itana:2005}).

Outra importante características para especificar o uso do ETL4NoSQL são os processos de ETL, que possuem quatro etapas básicas: extração, limpeza/transformação e carga (\cite{kimball:2004}). O fluxo do processo de ETL inicia-se com a extração dos dados a partir de uma fonte. A partir da extração, é possível que um componente passe os dados para uma \acp{apd}, onde é possível modelar os dados executando processos de limpeza e transformação por meio de mecanismos de junção, filtro, união, agregação e outros. Finalmente, os dados podem ser carregados em estrutura de dados.

Dessa forma, o ETL4NoSQL possui um componente que permite a leitura dos dados de diversos SGBDs NoSQL, de arquivos textuais, além dos SGBDs relacionais. Outro componente que permite a execução dos mecanismos de ETL, este componente também faz uso de componentes para o gerenciamento da execução dos processos, bem como a construção e sequência dos processos de ETL e a escolha do tipo de processamento. O ETL4NoSQL é composto também de um componente que permite carregar diretamente os dados no destino independente do seu tipo. No quadro \ref{requisitos} é apresentado os principais requisitos elencados do ETL4NoSQL. Foi definido como importante as prioridades que são imprescindíveis para o desenvolvimento e funcionamento do framework, e desejável as funcionalidades que aprimoram o uso do framework, porém não interferem no seu principal objetivo.

\begin{table}[h]
	\centering
	\caption{Requisitos do ETL4NoSQL}
	\label{requisitos}
	\begin{tabular}{|p{3cm}| p{10cm}| p{2cm} |}
		\hline
		Funcionalidade & Requisito & Prioridade\\
		\hline
		Suporte à plataforma &  Ser independente de plataforma & Importante\\
		\hline
		Suporte à fonte &  Ser capaz de ler diretamente da fonte de dados, independente do seu tipo, saber se é uma fonte RDBMS, arquivo de texto, XML ou NoSQL. & Importante\\
		\hline
		Suporte ao destino & Ser capaz de carregar diretamente os dado no destino, independente do  seu tipo, saber se o destino é RDBMS, arquivo de texto, XML ou NoSQL. & Importante\\
		\hline
		Suporte à modelagem & Apoiar na extração de dados de múltiplas fontes, na limpeza dos dados, e na transformação, agregação, reorganização e operações de carga. & Importante\\
		\hline
		Paralelismo &Apoiar as operações de vários segmentos e execução em paralelo, internamente. A ferramenta deve ser capaz de distribuir tarefas entre múltiplos servidores. & Importante\\
		\hline
		Programável &Apoiar o agendamento de tarefas de ETL e ter suporte para programação em linha de comandos usando programação externa. & Importante\\
		\hline
		Reutilização & Apoiar a reutilização dos componentes do framework e da lógica das transformações para evitar a reescrita. & Importante\\
		\hline
		Apoio ao nível de debugging & Apoiar o tempo de execução e a limpeza da lógica de transformação. O usuário deve ser capaz de ver os dados antes e depois da transformação. & Desejável\\
		\hline
		Implementação & Suportar a capacidade de agrupar os objetos ETL e implementá-los em ambiente de teste ou de produção, sem a intervenção de um administrador de ETL. & Desejável\\
		\hline
		Garantia de Qualidade & Ser capaz de estabelecer processos, métricas e avaliações que possibilitem e garantam a qualidade de software. & Desejável\\
		\hline
		
		
	\end{tabular}
\end{table}


\section{Modelagem do Domínio de ETL4NoSQL}

A modelagem do domínio de ETL4NoSQL é exposta a seguir através de seus três modelos: modelo conceitual, modelo de casos de uso e modelo de comportamento.

\subsection{Modelo Conceitual}

Os conceitos de aplicações ETL, identificados para o ETL4NoSQL, são: Fonte, Destino, Modelagem, Processamento, Operações, ProcessamentoDistribuído e ProcessamentoCentralizado. O modelo conceitual pode ser visualizado na figura \ref{modeloconceitual}.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.6]{fig/modeloconceitual.png}
	\caption{Modelo conceitual do ETL4NoSQL}
	\label{modeloconceitual}
\end{figure}

\subsection{Modelo de Casos de Uso}

Um conjunto de casos de uso pode ser identificado tal como: Ler fonte de dados, Escrever no destino, Modelar dados, Executar operação, Processar operações. O quadro \ref{casosdeuso} mostra a descrição sucinta de cada caso de uso.

\begin{table}[h!]
	\centering
	\caption{Modelo de Casos de Uso do ETL4NoSQL}
	\label{casosdeuso}
	\begin{tabular}{|p{14cm}|}
		\hline
			\textbf{Nome:} Ler fonte de dados\\ 
			\textbf{Objetivo:} Fazer a leitura de qualquer tipo de dados a partir de uma fonte de dados.\\ 
			\textbf{Pré-condição:} os parâmetros para permissão de conexão com a fonte de dados devem estar disponíveis.\\ 
			\textbf{Ação:} ler (Fonte)\\ 
		\hline
			\textbf{Nome:} Escrever no destino\\ 
			\textbf{Objetivo:} Fazer a escrita de qualquer tipo de dado a partir do modelo processado pelo ETL4NoSQL em uma base de destino.\\ 
			\textbf{Pré-condição:} os parâmetros para permissão de conexão e escrita com o destino devem estar disponíveis.\\ 
			\textbf{Ação:} escrever (Destino)  \\ 
	\hline
			\textbf{Nome:} Modelar dados\\ 
			\textbf{Objetivo:} Permitir a modelagem dos dados por meio de mecanismos de junção, filtro, união, agregação e outros. \\
			 \textbf{Pré-condição:} os mecanismos de transformação e limpeza devem estar disponíveis para executar a modelagem.\\ 
			 \textbf{Ação:} modelar (Modelagem, Operação)\\ 
	 \hline
	 		\textbf{Nome:} Executar operação\\ 
	 		\textbf{Objetivo:} Armazenar, gerenciar e executar as operações criadas pela ação de modelar.\\
	 		\textbf{Pré-condição:} as operações devem ser criadas previamente pela ação de modelar.\\ 
	 		\textbf{Ação:} executar (Operação, Processamento)\\ 
	 \hline
	 	\textbf{Nome:} Processar operações\\ 
	 	\textbf{Objetivo:} Processar as operações armazenadas de forma centralizada ou distribuída.\\
	 	\textbf{Pré-condição:} as operações precisam estar disponíveis para o processamento.\\ 
	 	\textbf{Ação:} processar (Processamento, Operação)\\ 
	 \hline
	 
	\end{tabular}
\end{table}

\subsection{Modelo Comportamental}

Ao construir o modelo comportamental é possível identificar os conceitos com comportamentos mais relevantes para o negócio, bem como os estados e eventos que disparam transições de estados (\cite{itana:2005}). Dessa forma, o diagrama de estados do ETL4NoSQL é apresentado na figura \ref{diagrama_estado}, nele podemos ver as transições de leitura da fonte, validação e identificação dos dados, assim como o tratamento caso os dados não possam ser identificados, subsequente a isso, o armazenamento dos dados para o processamento, a criação dos processos de ETL, a escolha da forma de processamento, execução das operações, e também o tratamento para operações que não puderem ser executadas, e finalmente, a carga dos dados na base destino seguido de uma mensagem de tratamento caso haja sucesso ou não da execução.

\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.6]{fig/diagrama_estado.png}
	\caption{Diagrama de Estado do ETL4NoSQL}
	\label{diagrama_estado}
\end{figure}

\section{Modelagem da Especificação do ETL4NoSQL}

A modelagem de especificação visa definir, em um nível alto de abstração, os serviços oferecidos pelos componentes \cite{itana:2005}. Dessa forma, é possível determinar a arquitetura e especificar os componentes. É importante dar ênfase a especificação das interfaces, pois isso contribui para uma clara separação entre os componentes, e também, para assegurar o princípio de encapsulamento de dados e comportamento \cite{itana:2005}. \cite{cheesman:2001} divide a modelagem da especificação em três estágio, sendo assim, os estágios da modelagem de especificação do ETL4NoSQL são apresentados a seguir.


\subsection{Identificação de Componentes}
Seguindo o modelo de conceitos do negócio e do modelo de casos de uso foi possível identificar as interfaces para os componentes de negócio, as interfaces de sistema para os componentes de sistema e gerar a arquitetura de componentes inicial. As interfaces de negócio são reconhecidas por meio do modelo conceitual e as interfaces de sistema e operações a partir dos casos de uso.

\subsection{Interfaces de Sistemas}

As interfaces de sistemas do ETL4NoSQL identificadas, por meio do modelo de casos de uso apresentado no quadro \ref{casosdeuso}, foram: IReadData, IWriteData, IModelData, IExeOp e IProcOp. Para especificar as interfaces foi utilizado OCL (\cite{warmer:1998}).



\begin{alltt}
	
\hrulefill	
\textbf{context} System :: IReadData (source : Fonte)

\textbf{pre:}
- A fonte é reconhecida, a conexão foi estabelecida	
Fonte.allInstances@includes(Fonte) Fonte.connection =
 estabelecido	
 
- Se não for possível estabelecer conexão
Fonte.allInstances@includes(Fonte) Fonte.connection = 
retorna mensagem de erro

- A estrutura de dados da fonte é reconhecido
Fonte.allInstances@includes(Fonte) Fonte.structureType = 
reconhecido

- Se a estrutura não puder ser reconhecida
Fonte.allInstances@includes(Fonte)Fonte.structureType = 
retorna mensagem de erro

\textbf{post:}
- Um novo objeto f do tipo Fonte foi criado
Fonte. allInstances@includes (f: Fonte | not 
Fonte.allInstances@pre@includes (f) and

- Os atributos do objeto f foram inicializados)	
\hrulefill

\textnormal{A partir da especificação foram identificadas as operações:		
Interface IReadData(Connection(connect), structureType())}

\hrulefill
\textbf{context} System :: IWriteData (load : Destino)

\textbf{pre:}
- O repositório destino estabeleceu conexão
Destino.allInstances@includes(Destino) Destino.connection = 
estabelecido

- Se não for possível estabelecer conexão
Destino.allInstances@includes(Destino) Destino.connection = 
retorna  erro

- A estrutura de dados de destino é reconhecida
Destino.allInstances@includes(Destino) Destino.structureType = 
reconhecido

- Se a estrutura não puder ser reconhecida
Destino.allInstances@includes(Destino)Destino.structureType = 
retorna  erro

- A estrutura de dados de destino permite a escrita dos dados
Destino.allInstances@includes(Destino) Destino.structureType = 
permissão de escrita

- Se a estrutura não permitir a escrita
Destino.allInstances@includes(Destino)Destino.structureType = 
retorna  erro

\textbf{post:}
- Um novo objeto d do tipo Destino foi criado
Fonte. allInstances@includes (d: Destino | not 
Destino.allInstances@pre@includes (d) and

- Os atributos do objeto d foram inicializados)
\hrulefill

\textnormal{As operações identificadas foram:
Interface IWriteData (connection(connect), structureType(), allowWrite())}

\hrulefill
\textbf{context} System :: IModelData (model : Modelagem; 
source: Fonte; operation: Operação)

\textbf{pre:}
- O repositório fonte e sua estrutura são reconhecidas
Fonte.allInstances@includes(Fonte) Fonte.connection = 
estabelecido and  Fonte.structureType = reconhecido

- Se não for possível estabelecer conexão
Fonte.allInstances@includes(Destino) Fonte.connection = 
retorna  erro

- Verifica se a operação existe
Operação.allInstances@includes(Operação) 
Operação.mecanismo = existe

- Se a operação não existir
Operação.allInstances@includes(Operação) 
Operação.mecanismo = retorna erro

- Cria a operação
Modelagem.allInstances@includes(Modelagem) 
Modelagem.operacao(dados)

\textbf{post:}
- Um novo objeto m do tipo Modelagem foi criado

Modelagem. allInstances@includes (m: Modelagem | not 
Destino.allInstances@pre@includes (m) and

- Os atributos do objeto m foram inicializados
- m foi ligado ao objeto f
f.Fonte = Fonte
- m foi ligado ao objeto o
o.Operação = Operação
- Todas as operações de modelagem foram criadas e 
armazenadas em um APD)
\hrulefill

\textnormal{As operações identificadas foram:
Interface IModelData (readData(CodFonte), createOp(CodOperação, data))}

\hrulefill
\textbf{context} System :: IExeOp (model : Modelagem; operation: 
Operação, processing: Processamento)

\textbf{pre:}
- As operações foram modeladas
Modelagem.allInstances@includes(Modelagem) 
Modelagem.operações = existem 

- Se não houver operações para executar
Operação.allInstances@includes(Operação) 
Operação.executa = retorna  erro

- As operações devem ser colocadas em ordem de execução
Operação.allInstances@includes(Operação) 
Operação.manage(operações)

\textbf{post:}
- Um novo objeto o do tipo Operação foi criado
Operação. allInstances@includes (o: Operação | not 
Operação.allInstances@pre@includes (o) and

- Os atributos do objeto o foram inicializados
- o foi ligado ao objeto m
m.Modelagem = Modelagem
- o foi ligado ao objeto p
p.Processamento = Processamento
- Todas as operações escalonadas e estão pronta para 
o processamento)
\hrulefill

\textnormal{As operações identificadas foram:
Interface IExeOp (modelOperation(CodModelagem), operationManagement())}

\hrulefill
\textbf{context} System :: IProcOp (operation: Operação, 
processing: Processamento)

\textbf{pre:}
- As operações devem estar na ordem para execução
Operação.allInstances@includes(Operação) Operação.toExec = 
pronto

- O tipo de processamento foi escolhido
Processamento.allInstances@includes(Processamento) 
Processamento.typeProc(tipoProcessamento)

\textbf{post:}

- Um novo objeto p do tipo Processamento foi criado

Processamento. allInstances@includes (m: Processamento | not 
Destino.allInstances@pre@includes (p) and

- Os atributos do objeto p foram inicializados
- p foi ligado ao objeto o
o.Operação = Operação
- É gerado o processamento das operações de acordo 
com o tipo escolhido)

\hrulefill

\textnormal{As operações identificadas foram:
Interface IProcOp (process(CodOperação), typeProc(tipoProcessamento))}

\end{alltt}


\subsection{Interfaces de Negócio}

Para definir as dependências no modelo \cite{cheesman:2001}, identificam o conceito de tipos principais, sendo estes tipos que possuem existência independente.
No ETL4NoSQL foi possível identificar quatro tipos principais: Fonte, Modelagem, Operação e Processamento. Para cada tipo principal foi possível definir uma interface de negócio, como é apresentado na figura \ref{modelo_negocio}.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.58]{fig/modelo_negocio.png}
	\caption{Definição de interfaces do modelo de negócio do ETL4NoSQL}
	\label{modelo_negocio}
\end{figure}

\subsection{Especificação da Arquitetura do Componente}

\cite{sommerville:2013}, define o projeto de arquitetura como um processo criativo em que se tenta organizar o sistema de acordo com os requisitos funcionais e não funcionais. Um estilo de arquitetura é um padrão de organização de sistema (\cite{shaw:1996}, \cite{sommerville:2013}), como uma organização cliente-servidor ou uma arquitetura em camadas. Porém, a arquitetura não necessariamente utilizará apenas um estilo, a maioria dos sistemas de médio e grande porte utilizam vários estilos. Para \cite{shaw:1996}, há três questões a serem definidas na escolha do projeto de arquitetura, a primeira é a escolha da estrutura, cliente-servidor ou em camadas, que permita atender melhor aos requisitos. A segunda questão é a respeito da decomposição dos subsistemas em módulos ou em componentes. E por fim, deve-se tomar a decisão de sobre como a execução dos subsistemas é controlada. A descrição da arquitetura pode ser representada graficamente utilizando modelos informais e notações como a UML (\cite{clements:2002}, \cite{sommerville:2013}). Para o ETL4NoSQL, cada componente foi associado à sua interface de negócio identificada e uma interface de gerenciamento foi separada das outras interfaces de negócio, como pode ser visto na figura \ref{arquitetura}.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{fig/arquitetura_comp.png}
	\caption{Especificação da arquitetura do componente de ETL4NoSQL}
	\label{arquitetura}
\end{figure}

\section{Interação entre Componentes}

Esta etapa é detalhada, em termos de interações, utilizando diagramas de colaboração. Dessa forma, apresentamos os diagramas de colaboração para as interações do ETL4NoSQL na seção a seguir.

\subsection{Operações da interface de negócio}

As operações de negócio são identificadas quando as interações forem analisadas para cada interface do sistema. Analisando as pré e pós-condições das operações de interface do sistema identificadas anteriormente foi possível detalhar usando diagramas de colaboração as interações necessárias para efetuar as operações do ETL4NoSQL. Os diagramas de cada operação podem ser visto nas figuras \ref{colaboracao1}, \ref{colaboracao2}, \ref{colaboracao3}, \ref{readData}, \ref{createOp}, \ref{createOp}, \ref{modelOperation}, \ref{operationManagement} e \ref{process}.

A conexão com a fonte de dados é estabelecida:

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{fig/colaboracao1.png}
	\caption{Diagrama de colaboração para conectar à base de fonte de dados}
	\label{colaboracao1}
\end{figure}

A estrutura de dados da fonte é reconhecido:

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{fig/colaboracao2.png}
	\caption{Diagrama de colaboração para verificar a estrutura de dados}
	\label{colaboracao2}
\end{figure}

A escrita na base de dados destino é permitida:

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{fig/colaboracao3.png}
	\caption{Diagrama de colaboração para verificar se existe permissão de escrita na base de dados destino}
	\label{colaboracao3}
\end{figure}

A leitura dos dados da fonte é feita e armazenada na área de processamento de dados:

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{fig/readData.png}
	\caption{Diagrama de colaboração para leitura dos dados da fonte}
	\label{readData}
\end{figure}

Após a leitura dos dados da fonte é possível a criação das operações por meio dos mecanismos existentes:

\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.5]{fig/createOp.png}
	\caption{Diagrama de colaboração criação das operações de ETL}
	\label{createOp}
\end{figure}

Com as operações criadas, deve-se colocá-las em ordem de execução:

\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.5]{fig/modelOperation.png}
	\caption{Diagrama de colaboração modelar as operações criadas}
	\label{modelOperation}
\end{figure}

É possível também que as operações sejam apagadas e alteradas:

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{fig/operationManagement.png}
	\caption{Diagrama de colaboração para gerenciar as operações}
	\label{operationManagement}
\end{figure}

Com as operações criadas é possível processá-las de forma a escolher o tipo de processamento (centralizado ou distribuído):

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{fig/process.png}
	\caption{Diagrama de colaboração para processar as operações}
	\label{process}
\end{figure}

\section{Especificação de Componentes}

Posteriormente à definição das interfaces de negócio, é possível detalhá-las. Para cada interface, as operações são especificadas com suas assinaturas, pré e pós-condições.

\begin{alltt}
	
	\textbf{context} IDataMgt :: connection(connect):Fonte
		\textbf{pré:}
		- Existe um parâmetro de conexão "connect"
		- Existe uma fonte para ser conectada
		\textbf{pós:}
		- A conexão com a fonte é estabelecida ou não
		- Recebe uma mensagem de conexão bem sucedida ou erro

	\textbf{context} IDataMgt :: strutuctureType():Fonte
		\textbf{pré:}
		- A conexão com a fonte foi bem sucedida
		\textbf{pós:}
		- A estrutura de dados é reconhecida ou não
		- Retorna mensagem de sucesso ou erro
		
	\textbf{context} IDataMgt :: allowWrite():Destino
		\textbf{pré:}
		- A conexão com o destino foi bem sucedida
		\textbf{pós:}
		- A base de dados destino permite escrita ou não
		- Retorna mensagem de sucesso ou erro
	
	\textbf{context} IModelMgt :: readData(codFonte, data):APD
		\textbf{pré:}
		- A conexão com a fonte foi bem sucedida
		- A estrutura de dados é reconhecida
		- Existe um parâmetro de busca "data" válido para 
		estrutura de dados reconhecida
		\textbf{pós:}
		- A leitura dos dados é realizada ou não
		- Retorna os dados em uma APD ou uma mensagem de erro
		
	\textbf{context} IModelMgt :: createOp(codOp, data):Operação
		\textbf{pré:}
		- Existe o mecanismo desejado para a criação da operação
		- Existe um parâmetro "data" com os dados a serem 
		usados na operação
		\textbf{pós:}
		- A operação é criada ou não
		- Retorna o codOp ou uma mensagem de erro
		
	\textbf{context} IOpMgt :: modelOperation(codModel)
		\textbf{pré:}
		- Existem operações criadas na APD (codModel)
		\textbf{pós:}
		- As operações são ordenadas para execução
		
	\textbf{context} IOpMgt :: operationManagement(codModel)
		\textbf{pré:}
		- Existem operações criadas na APD (codModel)
		\textbf{pós:}
		- As operações foram alteradas, apagadas ou não
		- Retorna mensagem de sucesso ou erro
	
	\textbf{context} IProcMgt :: process(codOp)
		\textbf{pré:}
		- Existe a operação (codOp)
		- Foi escolhido o tipo de processamento (centralizado ou distribuído)
		\textbf{pós:}
		- A operação foi processada ou não
		- Retorna mensagem de sucesso ou erro
		
			
\end{alltt}

Depois das operações terem sido especificadas, o diagrama de especificação das interfaces foi criado e está representado na figura \ref{interfaces}. Essas especificações se referem ao uso dos componentes. Elas representam o que o usuário precisa saber sobre os componentes.

\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.4]{fig/interfaces.png}
	\caption{Diagrama de especificação das interfaces de ETL4NoSQL}
	\label{interfaces}
\end{figure}

%De forma a detalhar a modelagem de especificação dos componentes deste trabalho, criamos um \textit{workflow} que é apresentado na figura \ref{modeloespecificacao} utilizando modelos informais e notações como a UML (\cite{clements:2002}).

%O modelo de processo do funcionamento da ferramenta ETL4NoSQL, baseado nas notações da UML 2.0 (\cite{clements:2002}), é representado na figura \ref{modeloprocesso}. Esse modelo descreve o processamento dos dados nas atividades de identificação dos dados, obtenção das informações para a importação e o mapeamento dos dados para os esquemas desejados, e também, a atividade dos processos de ETL para por fim dar carga dos dados em DWs, repositórios analíticos ou em arquivos XML.


% fluxo de processos da ferramenta ETL4NoSQL é o diagrama de atividades, que de acordo com a UML 2.0 tem como objetivo mostrar o fluxo de atividades em um único processo. O diagrama mostra como um atividade depende uma da outra. Na figura \ref{diagramaatividades} o diagrama mostra a interação dos componentes ao executar um processo de ETL, onde o estágio inicial é a importação dos dados seguido pelo mapeamento, após a obtenção dos dados necessários é possível a execução dos diversos processos de ETL em uma área de processamento para finalmente os dados serem exportados para base de destino.
%% utilizar diagrama de fluxo de dados para descrever os requisitos do sistema e diagrama de interações


%%construir um diagrama de atividades da execução de um processo de ETL



\section{Considerações Finais}


